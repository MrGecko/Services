{
  "_args": [
    [
      {
        "raw": "seneca-transport@2.1.0",
        "scope": null,
        "escapedName": "seneca-transport",
        "name": "seneca-transport",
        "rawSpec": "2.1.0",
        "spec": "2.1.0",
        "type": "version"
      },
      "/Users/mrgecko/Documents/Dev/Projects/services/seneca-server/node_modules/seneca"
    ]
  ],
  "_from": "seneca-transport@2.1.0",
  "_id": "seneca-transport@2.1.0",
  "_inCache": true,
  "_location": "/seneca-transport",
  "_nodeVersion": "5.11.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/seneca-transport-2.1.0.tgz_1472146380373_0.3452868014574051"
  },
  "_npmUser": {
    "name": "mihaidma",
    "email": "mihaizn@gmail.com"
  },
  "_npmVersion": "3.8.6",
  "_phantomChildren": {
    "gex": "0.2.2"
  },
  "_requested": {
    "raw": "seneca-transport@2.1.0",
    "scope": null,
    "escapedName": "seneca-transport",
    "name": "seneca-transport",
    "rawSpec": "2.1.0",
    "spec": "2.1.0",
    "type": "version"
  },
  "_requiredBy": [
    "/seneca"
  ],
  "_resolved": "https://registry.npmjs.org/seneca-transport/-/seneca-transport-2.1.0.tgz",
  "_shasum": "06675938f3c6f20bf1b6fb4b54807ec9846b3ec7",
  "_shrinkwrap": null,
  "_spec": "seneca-transport@2.1.0",
  "_where": "/Users/mrgecko/Documents/Dev/Projects/services/seneca-server/node_modules/seneca",
  "author": {
    "name": "Richard Rodger",
    "url": "http://richardrodger.com"
  },
  "bugs": {
    "url": "https://github.com/senecajs/seneca-transport/issues"
  },
  "contributors": [
    {
      "name": "Richard Rodger",
      "url": "https://github.com/rjrodger"
    },
    {
      "name": "Wyatt Preul",
      "url": "https://github.com/geek"
    },
    {
      "name": "Dean McDonnell",
      "url": "https://github.com/mcdonnelldean"
    },
    {
      "name": "Mihai Dima",
      "url": "https://github.com/mihaidma"
    },
    {
      "name": "David Gonzalez",
      "url": "https://github.com/dgonzalez"
    },
    {
      "name": "Glen Keane",
      "url": "https://github.com/thekemkid"
    },
    {
      "name": "Marco Piraccini",
      "url": "https://github.com/marcopiraccini"
    },
    {
      "name": "Shane Lacey",
      "url": "https://github.com/shanel262"
    },
    {
      "name": "Cristian Kiss",
      "url": "https://github.com/ckiss"
    },
    {
      "name": "jaamison",
      "url": "https://github.com/jaamison"
    },
    {
      "name": "peterli888",
      "url": "https://github.com/peterli888"
    },
    {
      "name": "Emer Rutherford",
      "url": "https://github.com/eeswr"
    },
    {
      "name": "Greg Kubisa",
      "url": "https://github.com/gkubisa"
    },
    {
      "name": "Geoffrey Clements",
      "url": "https://github.com/baldmountain"
    },
    {
      "name": "Rumkin",
      "url": "https://github.com/rumkin"
    },
    {
      "name": "Boris Jonica",
      "url": "https://github.com/bjonica"
    },
    {
      "name": "Damien Simonin Feugas",
      "url": "https://github.com/feugy"
    }
  ],
  "dependencies": {
    "eraro": "0.4.1",
    "gex": "0.2.2",
    "jsonic": "0.2.2",
    "lodash": "4.15.0",
    "lru-cache": "4.0.1",
    "ndjson": "1.4.3",
    "nid": "0.3.2",
    "patrun": "0.5.0",
    "qs": "6.2.1",
    "reconnect-core": "1.3.0",
    "wreck": "9.0.0"
  },
  "description": "Seneca transport",
  "devDependencies": {
    "async": "2.0.x",
    "bench": "0.3.x",
    "code": "3.0.x",
    "coveralls": "2.11.x",
    "docco": "0.7.x",
    "eslint-config-seneca": "3.x.x",
    "eslint-plugin-hapi": "4.x.x",
    "eslint-plugin-standard": "2.x.x",
    "lab": "11.0.x",
    "pre-commit": "1.1.x",
    "seneca": "plugin",
    "seneca-entity": "1.3.x",
    "seneca-transport-test": "0.2.0"
  },
  "directories": {},
  "dist": {
    "shasum": "06675938f3c6f20bf1b6fb4b54807ec9846b3ec7",
    "tarball": "https://registry.npmjs.org/seneca-transport/-/seneca-transport-2.1.0.tgz"
  },
  "files": [
    "transport.js",
    "README.md",
    "LICENSE.txt",
    "bench.js",
    "lib"
  ],
  "gitHead": "2db90a3184e010f1504f996eb34d758a4b3b4b01",
  "homepage": "https://github.com/senecajs/seneca-transport#readme",
  "keywords": [
    "seneca",
    "transport",
    "plugin"
  ],
  "license": "MIT",
  "main": "transport.js",
  "maintainers": [
    {
      "name": "mihaidma",
      "email": "mihaizn@gmail.com"
    },
    {
      "name": "rjrodger",
      "email": "richard.rodger@nearform.com"
    },
    {
      "name": "wyatt",
      "email": "wpreul@gmail.com"
    }
  ],
  "name": "seneca-transport",
  "optionalDependencies": {},
  "pre-commit": [
    "test"
  ],
  "precommit": "test",
  "readme": "![Seneca](http://senecajs.org/files/assets/seneca-logo.png)\n> A [Seneca.js][] transport plugin\n\n# seneca-transport\n[![npm version][npm-badge]][npm-url]\n[![Build Status][travis-badge]][travis-url]\n[![Dependency Status][david-badge]][david-url]\n[![Gitter][gitter-badge]][gitter-url]\n\n## Description\n\nThis plugin provides the HTTP/HTTPS and TCP transport channels for\nmicro-service messages. It's a built-in dependency of the Seneca\nmodule, so you don't need to include it manually. You use this plugin\nto wire up your micro-services so that they can talk to each other.\n\nseneca-transport's source can be read in an annotated fashion by:\n- running `npm run annotate`\n- viewing ./docs/annotated/transport.html locally\n\nIf you're using this module, and need help, you can:\n\n- Post a [github issue][],\n- Tweet to [@senecajs][],\n- Ask on the [Gitter][gitter-url].\n\nIf you are new to Seneca in general, please take a look at [senecajs.org][]. We have everything from\ntutorials to sample apps to help get you up and running quickly.\n\n### Seneca compatibility\nSupports Seneca versions **1.x** - **3.x**\n\n## Install\n\nThis plugin module is included in the main Seneca module:\n\n```sh\nnpm install seneca\n```\n\nTo install separately, use:\n\n```sh\nnpm install seneca-transport\n```\n\n\n## Quick Example\n\nLet's do everything in one script to begin with. You'll define a\nsimple Seneca plugin that returns the hex value of color words. In\nfact, all it can handle is the color red!\n\nYou define the action pattern _color:red_, which always returns the\nresult <code>{hex:'#FF0000'}</code>. You're also using the name of the\nfunction _color_  to define the name of the plugin (see [How to write a\nSeneca plugin](http://senecajs.org/tutorials/how-to-write-a-plugin.html)).\n\n```js\nfunction color() {\n  this.add( 'color:red', function(args,done){\n    done(null, {hex:'#FF0000'});\n  })\n}\n```\n\nNow, let's create a server and client. The server Seneca instance will\nload the _color_  plugin and start a web server to listen for inbound\nmessages. The client Seneca instance will submit a _color:red_ message\nto the server.\n\n\n```js\nvar seneca = require('seneca')\n\nseneca()\n  .use(color)\n  .listen()\n\nseneca()\n  .client()\n  .act('color:red')\n```\n\nExample with HTTPS:\n\nTo enable HTTPS, pass an options object to the `listen` function setting the `protocol` option to 'https' and provide a `serverOptions` object with `key` and `cert` properties.\n\n```js\nvar seneca = require('seneca')\nvar Fs = require('fs')\n\n\nseneca()\n  .use(color)\n  .listen({\n    type: 'http',\n    port: '8000',\n    host: 'localhost',\n    protocol: 'https',\n    serverOptions : {\n      key : Fs.readFileSync('path/to/key.pem', 'utf8'),\n      cert : Fs.readFileSync('path/to/cert.pem', 'utf8')\n    }\n  })\n\nseneca()\n  .client({\n    type: 'http',\n    port: '8000',\n    host: 'localhost',\n    protocol: 'https'\n  })\n  .act('color:red')\n```\n\nYou can create multiple instances of Seneca inside the same Node.js\nprocess. They won't interfere with each other, but they will share\nexternal options from configuration files or the command line.\n\nIf you run the full script (full source is in\n[readme-color.js](https://github.com/senecajs/seneca-transport/blob/master/test/readme-color.js)),\nyou'll see the standard Seneca startup log messages, but you won't see\nanything that tells you what the _color_ plugin is doing since this\ncode doesn't bother printing the result of the action. Let's use a\nfiltered log to output the inbound and outbound action messages from\neach Seneca instance so we can see what's going on. Run the script with:\n\n```sh\nnode readme-color.js --seneca.log=type:act,regex:color:red\n```\n\n_NOTE: when running the examples in this documentation, you'll find\nthat most of the Node.js processes do not exit. This because they\nrunning in server mode. You'll need to kill all the Node.js processes\nbetween execution runs. The quickest way to do this is:_\n\n```sh\n$ killall node\n```\n\n\nThis log filter restricts printed log entries to those that report\ninbound and outbound actions, and further, to those log lines that\nmatch the regular expression <code>/color:red/</code>. Here's what\nyou'll see:\n\n```sh\n[TIME] vy../..15/- DEBUG act -     - IN  485n.. color:red {color=red}   CLIENT\n[TIME] ly../..80/- DEBUG act color - IN  485n.. color:red {color=red}   f2rv..\n[TIME] ly../..80/- DEBUG act color - OUT 485n.. color:red {hex=#FF0000} f2rv..\n[TIME] vy../..15/- DEBUG act -     - OUT 485n.. color:red {hex=#FF0000} CLIENT\n```\n\nThe second field is the identifier of the Seneca instance. You can see\nthat first the client (with an identifier of _vy../..15/-_) sends the\nmessage <code>{color=red}</code>. The message is sent over HTTP to the\nserver (which has an identifier of _ly../..80/-_). The server performs the\naction, generating the result <code>{hex=#FF0000}</code>, and sends\nit back.\n\nThe third field, <code>DEBUG</code>, indicates the log level. The next\nfield, <code>act</code> indicates the type of the log entry. Since\nyou specified <code>type:act</code> in the log filter, you've got a\nmatch!\n\nThe next two fields indicate the plugin name and tag, in this case <code>color\n-</code>. The plugin is only known on the server side, so the client\njust indicates a blank entry with <code>-</code>. For more details on\nplugin names and tags, see [How to write a Seneca\nplugin](http://senecajs.org/tutorials/how-to-write-a-plugin.html).\n\nThe next field (also known as the _case_) is either <code>IN</code> or\n<code>OUT</code>, and indicates the direction of the message. If you\nfollow the flow, you can see that the message is first inbound to the\nclient, and then inbound to the server (the client sends it\nonwards). The response is outbound from the server, and then outbound\nfrom the client (back to your own code). The field after that,\n<code>485n..</code>, is the message identifier. You can see that it\nremains the same over multiple Seneca instances. This helps you to\ndebug message flow.\n\nThe next two fields show the action pattern of the message, \n<code>color:red</code>, followed by the actual data of the request\nmessage (when inbound), or the response message (when outbound).\n\nThe last field <code>f2rv..</code> is the internal identifier of the\naction function that acts on the message. On the client side, there is\nno action function, and this is indicated by the <code>CLIENT</code>\nmarker. If you'd like to match up the action function identifier to\nmessage executions, add a log filter to see them:\n\n```\nnode readme-color.js --seneca.log=type:act,regex:color:red \\\n--seneca.log=plugin:color,case:ADD\n[TIME] ly../..80/- DEBUG plugin color - ADD f2rv.. color:red\n[TIME] vy../..15/- DEBUG act    -     - IN  485n.. color:red {color=red}   CLIENT\n[TIME] ly../..80/- DEBUG act    color - IN  485n.. color:red {color=red}   f2rv..\n[TIME] ly../..80/- DEBUG act    color - OUT 485n.. color:red {hex=#FF0000} f2rv..\n[TIME] vy../..15/- DEBUG act    -     - OUT 485n.. color:red {hex=#FF0000} CLIENT\n```\n\nThe filter <code>plugin:color,case:ADD</code> picks out log entries of\ntype _plugin_, where the plugin has the name _color_, and where the\n_case_ is ADD. These entries indicate the action patterns that a\nplugin has registered. In this case, there's only one, _color:red_.\n\nYou've run this example in a single Node.js process up to now. Of\ncourse, the whole point is to run it in separate processes! Let's do\nthat. First, here's the server:\n\n```js\nfunction color() {\n  this.add( 'color:red', function(args,done){\n    done(null, {hex:'#FF0000'});\n  })\n}\n\nvar seneca = require('seneca')\n\nseneca()\n  .use(color)\n  .listen()\n```\n\nRun this in one terminal window with:\n\n```sh\n$ node readme-color-service.js --seneca.log=type:act,regex:color:red\n```\n\nAnd on the client side:\n\n```js\nvar seneca = require('seneca')\n\nseneca()\n  .client()\n  .act('color:red')\n```\n\nAnd run with:\n\n```sh\n$ node readme-color-client.js --seneca.log=type:act,regex:color:red\n```\n\nYou'll see the same log lines as before, just split over the two processes. The full source code is the [test folder](https://github.com/senecajs/seneca-transport/tree/master/test).\n\n\n## Non-Seneca Clients\n\nThe default transport mechanism for messages is HTTP. This means you can communicate easily with a Seneca micro-service from other platforms. By default, the <code>listen</code> method starts a web server on port 10101, listening on all interfaces. If you run the _readme-color-service.js_ script again (as above), you can talk to it by _POSTing_ JSON data to the <code>/act</code> path. Here's an example using the command line _curl_ utility.\n\n```sh\n$ curl -d '{\"color\":\"red\"}' http://localhost:10101/act\n{\"hex\":\"#FF0000\"}\n```\n\nIf you dump the response headers, you'll see some additional headers that give you contextual information. Let's use the <code>-v</code> option of _curl_ to see them:\n\n```sh\n$ curl -d '{\"color\":\"red\"}' -v http://localhost:10101/act\n...\n* Connected to localhost (127.0.0.1) port 10101 (#0)\n> POST /act HTTP/1.1\n> User-Agent: curl/7.30.0\n> Host: localhost:10101\n> Accept: */*\n> Content-Length: 15\n> Content-Type: application/x-www-form-urlencoded\n>\n* upload completely sent off: 15 out of 15 bytes\n< HTTP/1.1 200 OK\n< Content-Type: application/json\n< Cache-Control: private, max-age=0, no-cache, no-store\n< Content-Length: 17\n< seneca-id: 9wu80xdsn1nu\n< seneca-kind: res\n< seneca-origin: curl/7.30.0\n< seneca-accept: sk5mjwcxxpvh/1409222334824/-\n< seneca-time-client-sent: 1409222493910\n< seneca-time-listen-recv: 1409222493910\n< seneca-time-listen-sent: 1409222493910\n< Date: Thu, 28 Aug 2014 10:41:33 GMT\n< Connection: keep-alive\n<\n* Connection #0 to host localhost left intact\n{\"hex\":\"#FF0000\"}\n```\n\nYou can get the message identifier from the _seneca-id_ header, and\nthe identifier of the Seneca instance from _seneca-accept_.\n\nThere are two structures that the submitted JSON document can take:\n\n   * Vanilla JSON containing your request message, plain and simple, as per the example above,\n   * OR: A JSON wrapper containing the client details along with the message data.\n\nThe JSON wrapper follows the standard form of Seneca messages used in\nother contexts, such as message queue transports. However, the simple\nvanilla format is perfectly valid and provided explicitly for\nintegration. The wrapper format is described below.\n\nIf you need Seneca to listen on a particular port or host, you can\nspecify these as options to the <code>listen</code> method. Both are\noptional.\n\n```js\nseneca()\n  .listen( { host:'192.168.1.2', port:80 } )\n```\n\nOn the client side, either with your own code, or the Seneca client,\nyou'll need to use matching host and port options.\n\n```bash\n$ curl -d '{\"color\":\"red\"}' http://192.168.1.2:80/act\n```\n\n```js\nseneca()\n  .client( { host:'192.168.1.2', port:80 } )\n```\n\nYou can also set the host and port via the Seneca options facility. When\nusing the options facility, you are setting the default options for\nall message transports. These can be overridden by arguments to individual\n<code>listen</code> and <code>client</code> calls.\n\nLet's run the color example again, but with a different port. On the server-side:\n\n```sh\n$ node readme-color-service.js --seneca.log=type:act,regex:color:red \\\n  --seneca.options.transport.port=8888\n```\n\nAnd the client-side:\n\n```sh\ncurl -d '{\"color\":\"red\"}' -v http://localhost:8888/act\n```\nOR\n\n```sh\n$ node readme-color-client.js --seneca.log=type:act,regex:color:red \\\n  --seneca.options.transport.port=8888\n```\n\n## Using the TCP Channel\n\nAlso included in this plugin is a TCP transport mechanism. The HTTP\nmechanism offers easy integration, but it is necessarily slower. The\nTCP transport opens a direct TCP connection to the server. The\nconnection remains open, avoiding connection overhead for each\nmessage. The client side of the TCP transport will also attempt to\nreconnect if the connection breaks, providing fault tolerance for\nserver restarts.\n\nTo use the TCP transport, specify a _type_ property to the\n<code>listen</code> and <code>client</code> methods, and give it the\nvalue _tcp_. Here's the single script example again:\n\n\n```js\nseneca()\n  .use(color)\n  .listen({type:'tcp'})\n\nseneca()\n  .client({type:'tcp'})\n  .act('color:red')\n```\n\nThe full source code is in the\n[readme-color-tcp.js](https://github.com/senecajs/seneca-transport/blob/master/test/readme-color-tcp.js)\nfile. When you run this script it would be great to verify that the\nright transport channels are being created. You'd like to see the\nconfiguration, and any connections that occur. By default, this\ninformation is printed with a log level of _INFO_, so you will see it\nif you don't use any log filters.\n\nOf course, we are using a log filter. So let's add another one to\nprint the connection details so we can sanity check the system. We want\nto print any log entries with a log level of _INFO_. Here's the\ncommand:\n\n```sh\n$ node readme-color-tcp.js --seneca.log=level:INFO \\\n  --seneca.log=type:act,regex:color:red\n```\n\nThis produces the log output:\n\n```sh\n[TIME] 6g../..49/- INFO  hello  Seneca/0.5.20/6g../..49/-\n[TIME] f1../..79/- INFO  hello  Seneca/0.5.20/f1../..79/-\n[TIME] f1../..79/- DEBUG act    -         - IN  wdfw.. color:red {color=red} CLIENT\n[TIME] 6g../..49/- INFO  plugin transport - ACT b01d.. listen open {type=tcp,host=0.0.0.0,port=10201,...}\n[TIME] f1../..79/- INFO  plugin transport - ACT nid1.. client {type=tcp,host=0.0.0.0,port=10201,...} any\n[TIME] 6g../..49/- INFO  plugin transport - ACT b01d.. listen connection {type=tcp,host=0.0.0.0,port=10201,...} remote 127.0.0.1 52938\n[TIME] 6g../..49/- DEBUG act    color     - IN  bpwi.. color:red {color=red} mcx8i4slu68z UNGATE\n[TIME] 6g../..49/- DEBUG act    color     - OUT bpwi.. color:red {hex=#FF0000} mcx8i4slu68z\n[TIME] f1../..79/- DEBUG act    -         - OUT wdfw.. color:red {hex=#FF0000} CLIENT\n```\n\nThe inbound and outbound log entries are as before. In addition, you\ncan see the _INFO_ level entries. At startup, Seneca logs a \"hello\"\nentry with the identifier of the current instance execution. This\nidentifier has the form:\n<code>Seneca/[version]/[12-random-chars]/[timestamp]/[tag]</code>.  This\nidentifier can be used for debugging multi-process message flows. The\nsecond part is a local timestamp. The third is an optional tag, which\nyou could provide with <code>seneca({tag:'foo'})</code>, although we\ndon't use tags in this example.\n\nThere are three _INFO_ level entries of interest. On the server-side,\nthe listen facility logs the fact that it has opened a TCP port, and\nis now listening for connections. Then the client-side logs that it\nhas opened a connection to the server. And finally the server logs the\nsame thing.\n\nAs with the HTTP transport example above, you can split this code into\ntwo processes by separating the client and server code. Here's the server:\n\n```js\nfunction color() {\n  this.add( 'color:red', function(args,done){\n    done(null, {hex:'#FF0000'});\n  })\n}\n\nvar seneca = require('seneca')\n\nseneca()\n  .use(color)\n  .listen({type:'tcp'})\n```\n\nAnd here's the client:\n\n```js\nseneca()\n  .client({type:'tcp'})\n  .act('color:red')\n```\n\nYou can cheat by running the HTTP examples with the additional command\nline option: <code>--seneca.options.transport.type=tcp</code>.\n\nTo communicate with a Seneca instance over TCP, you can send a message from the command line that Seneca understands:\n\n```sh\n# call the color:red action pattern\necho '{\"id\":\"w91/enj\",\"kind\":\"act\",\"origin\":\"h5x/146/..77/-\",\"act\":{\"color\":\"red\"},\"sync\":true}' | nc 127.0.0.1 10201\n\n```\n\nSeneca answers with a message like:\n\n```sh\n{\"id\":\"w91/enj\",\"kind\":\"res\",\"origin\":\"h5x/146/..77/-\",\"accept\":\"bj../14../..47/-\",\"time\":{\"client_sent\":..,\"listen_recv\":..,\"listen_sent\":..},\"sync\":true,\"res\":{\"hex\":\"#FF0000\"}}\n# the produced result is in the \"res\" field\n```\n\nHTTP and TCP are not the only transport mechanisms available. Of\ncourse, in true Seneca-style, the other mechanisms are available as\nplugins. Here's the list.\n\n   * [redis-transport](https://github.com/senecajs/seneca-redis-transport): uses redis for a pub-sub message distribution model\n   * [beanstalk-transport](https://github.com/senecajs/seneca-beanstalk-transport): uses beanstalkd for a message queue\n   * [balance-client](https://github.com/rjrodger/seneca-balance-client): a load-balancing client transport over multiple Seneca listeners\n\nIf you're written your own transport plugin (see below for\ninstructions), and want to have it listed here, please submit a pull\nrequest.\n\n\n## Multiple Channels\n\nYou can use multiple <code>listen</code> and <code>client</code>\ndefinitions on the same Seneca instance, in any order. By default, a\nsingle <code>client</code> definition will send all unrecognized\naction patterns over the network. When you have multiple client\ndefinitions, it's becuase you want to send some action patterns to one\nmicro-service, and other patterns to other micro-services. To do this,\nyou need to specify the patterns you are interested in. In Seneca,\nthis is done with a `pin`.\n\nA Seneca `pin` is a pattern for action patterns. You provide a list of\nproperty names and values that must match. Unlike ordinary action\npatterns, where the values are fixed, with a `pin`, you can use globs\nto match more than one value. For example, let's say you have the patterns:\n\n   * <code>foo:1,bar:zed-aaa</code>\n   * <code>foo:1,bar:zed-bbb</code>\n   * <code>foo:1,bar:zed-ccc</code>\n\nThen you can use these `pins` to pick out the patterns you want:\n\n   * The pin <code>foo:1</code> matches the patterns <code>foo:1,bar:zed-aaa</code> and <code>foo:1,bar:zed-bbb</code> and <code>foo:1,bar:zed-ccc</code>\n   * The pin <code>foo:1, bar:*</code> also matches the patterns <code>foo:1,bar:zed-aaa</code> and <code>foo:1,bar:zed-bbb</code> and <code>foo:1,bar:zed-ccc</code>\n   * The pin <code>foo:1, bar:*-aaa</code> matches only the pattern <code>foo:1,bar:zed-aaa</code>\n\nLet's extend the color service example. You'll have three separate\nservices, all running in separate processes. They will listen on ports\n8081, 8082, and 8083 respectively. You'll use command line arguments\nfor settings. Here's the service code (see\n[readme-many-colors-server.js](https://github.com/senecajs/seneca-transport/blob/master/test/readme-many-colors-server.js)):\n\n```js\nvar color  = process.argv[2]\nvar hexval = process.argv[3]\nvar port   = process.argv[4]\n\nvar seneca = require('seneca')\n\nseneca()\n\n  .add( 'color:'+color, function(args,done){\n    done(null, {hex:'#'+hexval});\n  })\n\n  .listen( port )\n\n  .log.info('color',color,hexval,port)\n```\n\nThis service takes in a color name, a color hexadecimal value, and a\nport number from the command line. You can also see how the <code>listen</code>\nmethod can take a single argument, the port number. To offer the\n_color:red_ service, run this script with:\n\n```sh\n$ node readme-many-colors-server.js red FF0000 8081\n```\n\nAnd you can test with:\n\n```sh\n$ curl -d '{\"color\":\"red\"}' http://localhost:8081/act\n```\n\nOf course, you need to use some log filters to pick out the activity\nyou're interested in. In this case, you've used a\n<code>log.info</code> call to dump out settings. You'll also want to\nsee the actions as the occur. Try this:\n\n```sh\nnode readme-many-colors-server.js red FF0000 8081 --seneca.log=level:info \\\n  --seneca.log=type:act,regex:color\n```\n\nAnd you'll get:\n\n```sh\n[TIME] mi../..66/- INFO  hello  Seneca/0.5.20/mi../..66/-\n[TIME] mi../..66/- INFO  color  red       FF0000 8081\n[TIME] mi../..66/- INFO  plugin transport -      ACT 7j.. listen {type=web,port=8081,host=0.0.0.0,path=/act,protocol=http,timeout=32778,msgprefix=seneca_,callmax=111111,msgidlen=12,role=transport,hook=listen}\n[TIME] mi../..66/- DEBUG act    -         -      IN  ux.. color:red {color=red} 9l..\n[TIME] mi../..66/- DEBUG act    -         -      OUT ux.. color:red {hex=#FF0000} 9l..\n```\n\nYou can see the custom _INFO_ log entry at the top, and also the transport\nsettings after that.\n\nLet's run three of these servers, one each for red, green and\nblue. Let's also run a client to connect to them.\n\nLet's make it interesting. The client will <code>listen</code> so that it can\nhandle incoming actions, and pass them on to the appropriate server by\nusing a <code>pin</code>. The client will also define a new action that can\naggregate color lookups.\n\n```js\nvar seneca = require('seneca')\n\nseneca()\n\n  // send matching actions out over the network\n  .client({ port:8081, pin:'color:red' })\n  .client({ port:8082, pin:'color:green' })\n  .client({ port:8083, pin:'color:blue' })\n\n  // an aggregration action that calls other actions\n  .add( 'list:colors', function( args, done ){\n    var seneca = this\n    var colors = {}\n\n    args.names.forEach(function( name ){\n      seneca.act({color:name}, function(err, result){\n        if( err ) return done(err);\n\n        colors[name] = result.hex\n        if( Object.keys(colors).length == args.names.length ) {\n          return done(null,colors)\n        }\n      })\n    })\n\n  })\n\n  .listen()\n\n  // this is a sanity check\n  .act({list:'colors',names:['blue','green','red']},console.log)\n```\n\nThis code calls the <code>client</code> method three times. Each time,\nit specifies an action pattern <code>pin</code>, and a destination port. And\naction submitted to this Seneca instance via the <code>act</code>\nmethod will be matched against these <code>pin</code> patterns. If there is a\nmatch, they will not be processed locally. Instead they will be sent\nout over the network to the micro-service that deals with them.\n\nIn this code, you are using the default HTTP transport, and just\nchanging the port number to connect to. This reflects the fact that\neach color micro-service runs on a separate port.\n\nThe `listen` call at the bottom makes this \"client\" also\nlisten for inbound messages. So if you run, say the _color:red_\nservice, and also run the client, then you can send color:red messages\nto the client.\n\nYou need to run four processes:\n\n```sh\nnode readme-many-colors-server.js red FF0000 8081 --seneca.log=level:info --seneca.log=type:act,regex:color &\nnode readme-many-colors-server.js green 00FF00 8082 --seneca.log=level:info --seneca.log=type:act,regex:color &\nnode readme-many-colors-server.js blue 0000FF 8083 --seneca.log=level:info --seneca.log=type:act,regex:color &\nnode readme-many-colors-client.js --seneca.log=type:act,regex:CLIENT &\n\n```\n\nAnd then you can test with:\n\n```sh\n$ curl -d '{\"color\":\"red\"}' http://localhost:10101/act\n$ curl -d '{\"color\":\"green\"}' http://localhost:10101/act\n$ curl -d '{\"color\":\"blue\"}' http://localhost:10101/act\n```\n\nThese commands are all going via the client, which is listening on port 10101.\n\nThe client code also includes an aggregation action,\n_list:colors_. This lets you call multiple color actions and return\none result. This is a common micro-service pattern.\n\nThe script\n[readme-many-colors.sh](https://github.com/senecajs/seneca-transport/blob/master/test/readme-many-colors.sh)\nwraps all this up into one place for you so that it is easy to run.\n\nSeneca does not require you to use message transports. You can run\neverything in one process. But when the time comes, and you need to\nscale, or you need to break out micro-services, you have the option to\ndo so.\n\n\n## Message Protocols\n\nThere is no message protocol as such, as the data representation of\nthe underlying message transport is used. However, the plain text\nmessage representation is JSON in all known transports.\n\nFor the HTTP transport, message data is encoded as per the HTTP\nprotocol. For the TCP transport, UTF8 JSON is used, with one\nwell-formed JSON object per line (with a single \"\\n\" as line\nterminator).\n\nFor other transports, please see the documentation for the underlying\nprotocol. In general the transport plugins, such as\n_seneca-redis-transport_ will handle this for you so that you only\nhave to think in terms of JavaScript objects.\n\nThe JSON object is a wrapper for the message data. The wrapper contains\nsome tracking fields to make debugging easier. These are:\n\n   * _id_:     action identifier (appears in Seneca logs after IN/OUT)\n   * _kind_:   'act' for inbound actions, 'res' for outbound responses\n   * _origin_: identifier of orginating Seneca instance, where action is submitted\n   * _accept_: identifier of accepting Seneca instance, where action is performed\n   * _time_:\n      *   _client_sent_: client timestamp when message sent\n      *   _listen_recv_: server timestamp when message received\n      *   _listen_sent_: server timestamp when response sent\n      *   _client_recv_: client timestamp when response received\n   * _act_: action message data, as submitted to Seneca\n   * _res_: response message data, as provided by Seneca\n   * _error_: error message, if any\n   * _input_: input generating error, if any\n\n\n## Writing Your Own Transport\n\nTo write your own transport, the best approach is to copy one of the existing ones:\n\n   * [transport.js](https://github.com/senecajs/seneca-transport/blob/master/transport.js): disconnected or point-to-point\n   * [redis-transport.js](https://github.com/rjrodger/seneca-redis-transport/blob/master/lib/index.js): publish/subscribe\n   * [beanstalk-transport.js](https://github.com/rjrodger/seneca-beanstalk-transport/blob/master/lib/index.js): message queue\n\nChoose a _type_ for your transport, say \"foo\". You will need to\nimplement two patterns:\n\n   * role:transport, hook:listen, type:foo\n   * role:transport, hook:client, type:foo\n\nRather than writing all of the code yourself, and dealing with all the\nmessy details, you can take advantage of the built-in message\nserialization and error handling by using the utility functions that\nthe _transport_ plugin exports. These utility functions can be called\nin a specific sequence, providing a template for the implementation of\na message transport:\n\nThe transport utility functions provide the concept of topics. Each\nmessage pattern is encoded as a topic string (alphanumeric) that could\nbe used with a message queue server. You do not need to use topics,\nbut they can be convenient to separate message flows.\n\nTo implement the client, use the template:\n\n```js\nvar transport_utils = seneca.export('transport/utils')\n\nfunction hook_client_redis( args, clientdone ) {\n  var seneca         = this\n  var type           = args.type\n\n  // get your transport type default options\n  var client_options = seneca.util.clean(_.extend({},options[type],args))\n\n  transport_utils.make_client( make_send, client_options, clientdone )\n\n  // implement your transport here\n  // see an existing transport for full example\n  // make_send is called per topic\n  function make_send( spec, topic, send_done ) {\n\n    // setup topic in transport mechanism\n\n    // send the args over the transport\n    send_done( null, function( args, done ) {\n\n      // create message JSON\n      var outbound_message = transport_utils.prepare_request( seneca, args, done )\n\n      // send JSON using your transport API\n\n      // don't call done - that only happens if there's a response!\n      // this will be done for you\n    })\n  }\n}\n```\n\nTo implement the server, use the template:\n\n```js\nvar transport_utils = seneca.export('transport/utils')\n\nfunction hook_listen_redis( args, done ) {\n  var seneca         = this\n  var type           = args.type\n\n  // get your transport type default options\n  var listen_options = seneca.util.clean(_.extend({},options[type],args))\n\n  // get the list of topics\n  var topics = tu.listen_topics( seneca, args, listen_options )\n\n  topics.forEach( function(topic) {\n\n    // \"listen\" on the topic - implementation dependent!\n\n    // handle inbound messages\n    transport_utils.handle_request( seneca, data, listen_options, function(out){\n\n      // there may be no result!\n      if( null == out ) return ...;\n\n      // otherwise, send the result back\n      // don't forget to stringifyJSON(out) if necessary\n    })\n  })\n}\n```\n\nIf you do not wish to use a template, you can implement transports\nusing entirely custom code. In this case, you need to need to provide\nresults from the _hook_ actions. For the _role:transport,hook:listen_\naction, this is easy, as no result is required. For\n_role:transport,hook:client_, you need to provide an object with\nproperties:\n\n   * `id`: an identifier for the client\n   * `toString`: a string description for debug logs\n   * `match( args )`: return _true_ if the client can transport the given args (i.e. they match the client action pattern)\n   * `send( args, done )`: a function that performs the transport, and calls `done` with the result when received\n\nSee the `make_anyclient` and `make_pinclient` functions in\n[transport.js](transport.js) for implementation examples.\n\nMessage transport code should be written very carefully as it will be\nsubject to high load and many error conditions.\n\n\n## Plugin Options\n\nThe transport plugin family uses an extension to the normal Seneca\noptions facility. As well as supporting the standard method for\ndefining options (see [How to Write a\nPlugin](http://senecajs.org/tutorials/how-to-write-a-plugin.html#wp-options)), you can\nalso supply options via arguments to the <code>client</code> or\n<code>listen</code> methods, and via the type name of the transport\nunder the top-level _transport_ property.\n\nThe primary options are:\n\n   * _msgprefix_: a string to prefix to topic names so that they are namespaced\n   * _callmax_: the maximum number of in-flight request/response messages to cache\n   * _msgidlen_: length of the message indentifier string\n\nThese can be set within the top-level _transport_ property of the main\nSeneca options tree:\n\n```js\nvar seneca = require('seneca')\nseneca({\n  transport:{\n    msgprefix:'foo'\n  }\n})\n```\n\nEach transport type forms a sub-level within the _transport_\noption. The recognized types depend on the transport plugins you have\nloaded. By default, _web_ and _tcp_ are available. To use _redis_, for example, you\nneed to do this:\n\n```js\nvar seneca = require('seneca')\nseneca({\n    transport:{\n      redis:{\n        timeout:500\n      }\n    }\n  })\n\n  // assumes npm install seneca-redis-transport\n  .use('redis-transport')\n\n  .listen({type:'redis'})\n```\n\nYou can set transport-level options inside the type property:\n\n```js\nvar seneca = require('seneca')\nseneca({\n  transport:{\n    tcp:{\n      timeout:1000\n    }\n  }\n})\n```\n\nThe transport-level options vary by transport. Here are the default ones for HTTP:\n\n   * _type_: type name; constant: 'web'\n   * _port_: port number; default: 10101\n   * _host_: hostname; default: '0.0.0.0' (all interfaces)\n   * _path_: URL path to submit messages; default: '/act'\n   * _protocol_: HTTP protocol; default 'http'\n   * _timeout_: timeout in milliseconds; default: 5555\n   * _headers_: extra headers to include in requests the transport makes; default {}\n\nAnd for TCP:\n\n   * _type_: type name; constant: 'tcp'\n   * _port_: port number; default: 10201\n   * _host_: hostname; default: '0.0.0.0' (all interfaces)\n   * _timeout_: timeout in milliseconds; default: 5555\n\nThe <code>client</code> and <code>listen</code> methods accept an\noptions object as the primary way to specify options:\n\n```js\nvar seneca = require('seneca')\nseneca()\n  .client({timeout:1000})\n  .listen({timeout:2000})\n```\n\nAs a convenience, you can specify the port and host as optional arguments:\n\n```js\nvar seneca = require('seneca')\nseneca()\n  .client( 8080 )\n  .listen( 9090, 'localhost')\n```\n\nTo see the options actually in use at any time, you can call the\n<code>seneca.options()</code> method. Or try\n\n```sh\n$ node seneca-script.js --seneca.log=type:options\n```\n\n## Releases\n\n   * 0.9.0: Fixes from @technicallyjosh; proper glob matching with patrun 5.x\n   * 0.7.1: fixed log levels\n   * 0.7.0: all logs now debug level\n   * 0.2.6: fixed error transmit bug https://github.com/senecajs/seneca/issues/63\n\n## Testing with Docker Compose\n\nWith docker-machine and docker-compose installed run the following commands:\n\n```\ndocker-compose build\ndocker-compose up\n```\n\nThe output will be the stdout from the server and client logs.  You should also\nsee the client instance outputting the result from the server: `{ hex: '#FF0000' }`\n\n## Contributing\n\nThe [Senecajs org][] encourage open participation. If you feel you can help in any way, be it with\ndocumentation, examples, extra testing, or new features please get in touch.\n\n## Test\n\nTo run tests, simply use npm:\n\n```sh\nnpm run test\n```\n\n## License\n\nCopyright (c) 2013-2016, Richard Rodger and other contributors.\nLicensed under [MIT][].\n\n[npm-badge]: https://img.shields.io/npm/v/seneca-transport.svg\n[npm-url]: https://npmjs.com/package/seneca-transport\n[travis-badge]: https://travis-ci.org/senecajs/seneca-transport.svg\n[travis-url]: https://travis-ci.org/senecajs/seneca-transport\n[gitter-badge]: https://badges.gitter.im/Join%20Chat.svg\n[gitter-url]: https://gitter.im/senecajs/seneca\n[david-badge]: https://david-dm.org/senecajs/seneca-transport.svg\n[david-url]: https://david-dm.org/senecajs/seneca-transport\n[MIT]: ./LICENSE\n[Senecajs org]: https://github.com/senecajs/\n[Seneca.js]: https://www.npmjs.com/package/seneca\n[senecajs.org]: http://senecajs.org/\n[leveldb]: http://leveldb.org/\n[github issue]: https://github.com/senecajs/seneca-transport/issues\n[@senecajs]: http://twitter.com/senecajs\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/senecajs/seneca-transport.git"
  },
  "scripts": {
    "annotate": "docco transport.js -o docs/annotated; open docs/annotated/transport.html",
    "bench": "node bench",
    "coveralls": "lab -s -P test -r lcov | coveralls",
    "test": "lab -v -L -P test -t 81 -m 5000",
    "test-report": "lab -v -L -P test -t 81 -m 5000 -r html > test/report.html; open test/report.html"
  },
  "version": "2.1.0"
}
